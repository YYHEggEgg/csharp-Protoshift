using System.Collections.Concurrent;
using System.Text;

namespace YYHEggEgg.Logger
{
    /// <summary>
    /// 
    /// </summary>
    public class ConsoleWrapper
    {
        private static List<string> lines; // 记录每行输入的列表
        private static int currentLine; // 当前所在行的标记
        private static ConcurrentQueue<string> readqueue = new();
        public static event EventHandler? ShutDown; // 退出事件

        private static bool isReading;
        private static bool AddPrefix;
        public static int RefreshTicks { get; set; }
        private static StringBuilder input;
        private static int cursor;

        static ConsoleWrapper()
        {
            lines = new List<string>();
            currentLine = 0;
            Console.CancelKeyPress += Console_CancelKeyPress;
            InputPrefix = "";
            RefreshTicks = 2;

            Console.TreatControlCAsInput = true; // 允许Ctrl+C被视为输入
            input = new();
            cursor = 0;

            Task.Run(BackgroundUpdate);
        }

        private static void Console_CancelKeyPress(object? sender, ConsoleCancelEventArgs e)
        {
            e.Cancel = true;
            ShutDown?.Invoke(null, EventArgs.Empty);
        }

        #region Refresh Prefix
        // Reference:
        // [ Can Console.Clear be used to only clear a line instead of whole console? ]
        // https://stackoverflow.com/questions/8946808/can-console-clear-be-used-to-only-clear-a-line-instead-of-whole-console
        // Applied some modifications to support only clear current line.
        private static void ClearThisLine()
        {
            // if (Console.CursorTop > 0) Console.SetCursorPosition(0, Console.CursorTop - 1);
            int currentLineCursor = Console.CursorTop;
            Console.SetCursorPosition(0, Console.CursorTop);
            Console.Write(new string(' ', Console.WindowWidth));
            Console.SetCursorPosition(0, currentLineCursor);
        }

        /// <summary>
        /// 
        /// </summary>
        public static string InputPrefix { get; set; }
        private static object PrefixLock = "YYHEggEgg.Logger";
        #endregion

        #region Read & Write
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public static async Task<string> ReadLineAsync()
        {
            lock (PrefixLock)
            {
                isReading = true;
                AddPrefix = true;
                ClearWrittingArea();
                Console.Write(InputPrefix);
            }

            string? result;
            while (!readqueue.TryDequeue(out result))
            {
                await Task.Delay(RefreshTicks);
            }

            lock (PrefixLock)
            {
                AddPrefix = false;
                isReading = false;
            }

            return result;
        }

        #region WriteLine
        private static void BeginWrite()
        {
            lock (PrefixLock)
            {
                if (isReading)
                {
                    ClearWrittingArea();
                    AddPrefix = false;
                }
            }
        }

        private static void EndWrite()
        {
            lock (PrefixLock)
            {
                AddPrefix = true;
                Console.Write(InputPrefix);
                lock (PrefixLock)
                {
                    if (isReading)
                    {
                        Console.Write(input);
                        RecoverCursor();
                    }
                }
            }
        }

        /// <summary>
        /// WriteLine
        /// </summary>
        /// <param name="input">输出至控制台的文字。支持使用颜色，在文本中加入xml标签即可：&lt;color=Red&gt;红色文字&lt;&#47;color&gt;。颜色代码必须为<see cref="ConsoleColor"/>中的有效值，如"Red"、"Green"等。</param>
        private static void InnerWriteLine(string input)
        {
            try
            {
                // Generated by ChatGPT
                Console.ForegroundColor = ConsoleColor.White; //设置默认白色字体颜色
                int startIndex = 0;

                while (true)
                {
                    int colorStart = input.IndexOf("<color=", startIndex); //查找下一个彩色文字的起始位置
                    if (colorStart == -1) //若未找到，输出剩余部分并退出循环
                    {
                        Console.Write(input.Substring(startIndex, input.Length - startIndex));
                        break;
                    }

                    int colorEnd = input.IndexOf(">", colorStart); //查找彩色文字的结束位置
                    if (colorEnd == -1) //若未找到，输出剩余部分并退出循环
                    {
                        Console.Write(input.Substring(startIndex, input.Length - startIndex));
                        break;
                    }

                    string colorCode = input.Substring(colorStart + 7, colorEnd - colorStart - 7); //提取颜色代码
                    ConsoleColor color;

                    if (Enum.TryParse(colorCode, out color)) //尝试将字符串颜色代码解析为ConsoleColor枚举类型
                    {
                        Console.Write(input.Substring(startIndex, colorStart - startIndex)); //输出彩色文字前的部分
                        Console.ForegroundColor = color; //设置字体颜色
                        int textStart = colorEnd + 1;
                        int textEnd = input.IndexOf("</color>", textStart); //查找彩色文字结束标记
                        if (textEnd == -1) //若未找到，输出剩余部分并退出循环
                        {
                            Console.Write(input.Substring(textStart, input.Length - textStart));
                            break;
                        }
                        Console.Write(input.Substring(textStart, textEnd - textStart)); //输出彩色文字
                        Console.ForegroundColor = ConsoleColor.White; //恢复默认字体颜色
                        startIndex = textEnd + 8; //继续查找下一个彩色文字的起始位置
                    }
                    else //解析失败，跳过此次查找
                    {
                        startIndex = colorEnd + 1;
                    }
                }
            }
            catch
            {
                Log.Erro("Fatal Error. Search for \"resolving color\" in log file for more infomation.", "Logger");
            }
        }

        #region Outer WriteLine
        /// <summary>
        /// WriteLine
        /// </summary>
        /// <param name="input">输出至控制台的文字。支持使用颜色，在文本中加入xml标签即可：&lt;color=Red&gt;红色文字&lt;&#47;color&gt;。颜色代码必须为<see cref="ConsoleColor"/>中的有效值，如"Red"、"Green"等。</param>
        public static void WriteLine(string input)
        {
            BeginWrite();
            InnerWriteLine(input);
            EndWrite();
        }

        /// <summary>
        /// WriteLine
        /// </summary>
        /// <param name="input">输出至控制台的文字。支持使用颜色，在文本中加入xml标签即可：&lt;color=Red&gt;红色文字&lt;&#47;color&gt;。颜色代码必须为<see cref="ConsoleColor"/>中的有效值，如"Red"、"Green"等。</param>
        public static void WriteLine(string input1, string input2)
        {
            BeginWrite();
            InnerWriteLine(input1);
            InnerWriteLine(input2);
            EndWrite();
        }

        /// <summary>
        /// WriteLine
        /// </summary>
        /// <param name="input">输出至控制台的文字。支持使用颜色，在文本中加入xml标签即可：&lt;color=Red&gt;红色文字&lt;&#47;color&gt;。颜色代码必须为<see cref="ConsoleColor"/>中的有效值，如"Red"、"Green"等。</param>
        public static void WriteLine(string input1, string input2, string input3)
        {
            BeginWrite();
            InnerWriteLine(input1);
            InnerWriteLine(input2);
            InnerWriteLine(input3);
            EndWrite();
        }

        /// <summary>
        /// WriteLine
        /// </summary>
        /// <param name="input">输出至控制台的文字。支持使用颜色，在文本中加入xml标签即可：&lt;color=Red&gt;红色文字&lt;&#47;color&gt;。颜色代码必须为<see cref="ConsoleColor"/>中的有效值，如"Red"、"Green"等。</param>
        public static void WriteLine(IEnumerable<string> inputs)
        {
            BeginWrite();
            foreach (var input in inputs)
                InnerWriteLine(input);
            EndWrite();
        }

        /// <summary>
        /// WriteLine
        /// </summary>
        /// <param name="input">输出至控制台的文字。支持使用颜色，在文本中加入xml标签即可：&lt;color=Red&gt;红色文字&lt;&#47;color&gt;。颜色代码必须为<see cref="ConsoleColor"/>中的有效值，如"Red"、"Green"等。</param>
        public static void WriteLine(params string[] inputs) => WriteLine(inputs);
        #endregion
        #endregion
        #endregion

        #region Cursor Calculate
        private static void SetCursorHome()
        {
            int calcCursor = InputPrefix.Length + cursor;

            int inputlines = calcCursor / Console.WindowWidth;
            Console.SetCursorPosition(InputPrefix.Length, Console.CursorTop - inputlines);
        }

        private static void SetCursorEnd()
        {
            int calcCursor = InputPrefix.Length + input.Length;
            int forwardChars = Console.CursorLeft + input.Length - cursor + 1;

            int inputlines = calcCursor / Console.WindowWidth + 1;
            Console.SetCursorPosition(calcCursor % Console.WindowWidth, 
                Console.CursorTop + forwardChars / Console.WindowWidth);
        }

        private static void RecoverCursor()
        {
            SetCursorHome();
            int calcCursor = InputPrefix.Length + cursor;
            Console.SetCursorPosition(calcCursor % Console.WindowWidth,
                Console.CursorTop + calcCursor / Console.WindowWidth);
        }

        private static void ClearWrittingArea()
        {
            int occupiedLength = InputPrefix.Length + input.Length;
            while (occupiedLength > 0)
            {
                ClearThisLine();
                occupiedLength -= Console.WindowWidth;
                if (occupiedLength > 0)
                {
                    Console.SetCursorPosition(0, Console.CursorTop - 1);
                }
            }
        }
        #endregion

        private static async Task BackgroundUpdate()
        {
            ConsoleKeyInfo keyInfo;
            keyInfo = Console.ReadKey(!isReading);
            #region 清除整行的操作
            if (keyInfo.Key == ConsoleKey.Enter) // 整合输入的所有字符
            {
                lines.Add(input.ToString());
                readqueue.Enqueue(input.ToString());
                currentLine = lines.Count;
                input = new();
                cursor = 0;

                lock (PrefixLock)
                {
                    if (isReading) Console.Write(InputPrefix);
                }
            }
            else if (keyInfo.Key == ConsoleKey.UpArrow) // 切换cursor至上一行
            {
                if (currentLine > 0)
                {
                    currentLine--;
                    input = new(lines[currentLine]);
                    cursor = input.Length;

                    lock (PrefixLock)
                    {
                        if (isReading)
                        {
                            ClearWrittingArea();
                            Console.Write(InputPrefix);
                            if (isReading) Console.Write(input);
                        }
                    }
                }
            }
            else if (keyInfo.Key == ConsoleKey.DownArrow) // 切换cursor至下一行
            {
                if (currentLine < lines.Count - 1)
                {
                    currentLine++;
                    input = new(lines[currentLine]);
                    cursor = input.Length;

                    lock (PrefixLock)
                    {
                        if (isReading)
                        {
                            ClearWrittingArea();
                            Console.Write(InputPrefix);
                            if (isReading) Console.Write(input);
                        }
                    }
                }
            }
            #endregion
            else if (
                keyInfo.Key == ConsoleKey.C && keyInfo.Modifiers == ConsoleModifiers.Control
            ) // 触发ShutDown事件
            {
                ShutDown?.Invoke(null, EventArgs.Empty);
                return;
            }
            #region 主要处理光标的操作
            else if (
                keyInfo.Key == ConsoleKey.V && keyInfo.Modifiers == ConsoleModifiers.Control
            ) // 粘贴剪贴板内容
            {
                // Automatically handled by .NET Console
                //pasteText = Clipboard.GetText();
                //isCtrlV = true;
            }
            else if (keyInfo.Key == ConsoleKey.Backspace) // 处理退格
            {
                if (input.Length > 0)
                {
                    input.Remove(cursor - 1, 1);
                    cursor--;
                    lock (PrefixLock)
                    {
                        if (isReading)
                        {
                            // 按下 backspace 后，控制台会自动使光标后退一格，但不删除字符
                            int currentCursorLeft = Console.CursorLeft;
                            int currentCursorTop = Console.CursorTop;
                            Console.Write(' ');
                            Console.SetCursorPosition(currentCursorLeft, currentCursorTop);
                        }
                    }
                }
            }
            else if (keyInfo.Key == ConsoleKey.Delete)
            {
                if (input.Length > 0)
                {
                    input.Remove(cursor, 1);
                    lock (PrefixLock)
                    {
                        if (isReading)
                        {
                            int currentCursorLeft = Console.CursorLeft;
                            int currentCursorTop = Console.CursorTop;
                            Console.Write(' ');
                            if (Console.CursorLeft == 0) 
                                Console.SetCursorPosition(Console.WindowWidth, currentCursorTop - 1);
                            else Console.SetCursorPosition(currentCursorLeft - 1, currentCursorTop);
                        }
                    }
                }
            }
            else if (keyInfo.Key == ConsoleKey.Home)
            {
                lock (PrefixLock)
                {
                    if (isReading)
                    {
                        SetCursorHome();
                    }
                }
                cursor = 0;
            }
            else if (keyInfo.Key == ConsoleKey.End)
            {
                lock (PrefixLock)
                {
                    if (isReading)
                    {
                        SetCursorEnd();
                    }
                }
                cursor = input.Length;
            }
            else if (keyInfo.Key == ConsoleKey.LeftArrow)
            {
                if (cursor > 0)
                {
                    cursor--;
                    #region 控制台光标操作
                    lock (PrefixLock)
                    {
                        if (isReading)
                        {
                            // 按下上下左右键后，控制台光标不移动
                            int currentCursorLeft = Console.CursorLeft;
                            int currentCursorTop = Console.CursorTop;
                            if (currentCursorLeft == 0)
                                Console.SetCursorPosition(Console.WindowWidth, currentCursorTop - 1);
                            else
                                Console.SetCursorPosition(currentCursorLeft - 1, currentCursorTop);
                        }
                    }
                    #endregion
                }
            }
            else if (keyInfo.Key == ConsoleKey.RightArrow)
            {
                if (cursor < input.Length)
                {
                    cursor++;
                    #region 控制台光标操作
                    lock (PrefixLock)
                    {
                        if (isReading)
                        {
                            // 按下上下左右键后，控制台光标不移动
                            int currentCursorLeft = Console.CursorLeft;
                            int currentCursorTop = Console.CursorTop;
                            if (currentCursorLeft == Console.WindowWidth)
                                Console.SetCursorPosition(0, currentCursorTop + 1);
                            else
                                Console.SetCursorPosition(currentCursorLeft + 1, currentCursorTop);
                        }
                    }
                    #endregion
                }
            }
            #endregion
            else
            {
                input.Insert(cursor, keyInfo.KeyChar);
                cursor++;
            }

            await Task.Run(BackgroundUpdate);
        }
    }
}