// Generated by ChatGPT
#define SPECIAL_UDP_VERBOSE
#define SPECIAL_UDP_WARNING

#pragma warning disable CS8604 // 引用类型参数可能为 null。
#pragma warning disable CS8629 // 可为 null 的值类型可为 null。
#pragma warning disable CS8625 // 无法将 null 字面量转换为非 null 的引用类型。

using Org.BouncyCastle.Utilities;
using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using YYHEggEgg.Logger;

// Obsoleted for bad performance
namespace csharp_Protoshift.Obsoleted.SpecialUdp
{
    public sealed class ConcurrentUdpClient : IDisposable
    {
        #region Packet Utils
        private enum UdpInvoke
        {
            /// <summary>
            /// Equal to <see cref="UdpClient.Send(byte[], int)"/>.
            /// </summary>
            SendConnected = 1,
            /// <summary>
            /// Equal to <see cref="UdpClient.Send(byte[], int, IPEndPoint)"/>.
            /// </summary>
            SendAnyEndpoint = 2,
            /// <summary>
            /// Equal to <see cref="UdpClient.SendAsync(byte[], int)"/>.
            /// </summary>
            SendAsyncConnected = 11,
            /// <summary>
            /// Equal to <see cref="UdpClient.SendAsync(byte[], int, IPEndPoint)"/>.
            /// </summary>
            SendAsyncAnyEndpoint = 12,
            /// <summary>
            /// Equal to <see cref="UdpClient.SendAsync(ReadOnlyMemory{byte})"/>.
            /// </summary>
            SendAsyncMemoryConnected = 13,
            /// <summary>
            /// Equal to <see cref="UdpClient.SendAsync(ReadOnlyMemory{byte}, IPEndPoint)"/>.
            /// </summary>
            SendAsyncMemoryAnyEndpoint = 14,
            /// <summary>
            /// Equal to <see cref="UdpClient.Receive(IPEndPoint)"/>.
            /// </summary>
            Receive = 101,
            /// <summary>
            /// Equal to <see cref="UdpClient.ReceiveAsync()"/>.
            /// </summary>
            ReceiveAsync = 111
        }

        private class UdpSendPacket
        {
            public byte[]? data;
            public ReadOnlyMemory<byte>? memoryData;
            public int? bytes;
            public IPEndPoint? endpoint;
            public Exception? ex;
            public int? rtn;
            public UdpInvoke invoke;

            public UdpSendPacket(byte[] data, int bytes, IPEndPoint? endpoint, UdpInvoke invoke)
            {
                this.data = data;
                this.bytes = bytes;
                this.endpoint = endpoint;
                this.invoke = invoke;
            }

            public UdpSendPacket(ReadOnlyMemory<byte> memoryData, IPEndPoint? endpoint, UdpInvoke invoke)
            {
                this.memoryData = memoryData;
                this.endpoint = endpoint;
                this.invoke = invoke;
            }
        }

        private class UdpReceivePacket
        {
            public UdpReceiveResult? receiveData;
            public Exception? ex;
            public UdpInvoke invoke;

            public UdpReceivePacket(UdpInvoke invoke)
            {
                this.invoke = invoke;
            }
        }
        #endregion

        #region BeforeHand Initialize
        // 构造函数
        public ConcurrentUdpClient()
        {
            // 初始化UdpClient实例
            baseClient = new UdpClient();
#if SPECIAL_UDP_VERBOSE
            Log.Info("baseClient initialized with normal paramters.", "ConcurrentUdpClient");
#endif
            // 启动后台更新任务
            Task.Run(BackgroundUpdate);
        }

        public ConcurrentUdpClient(IPEndPoint bindAddress)
        {
            baseClient = new UdpClient(bindAddress);
#if SPECIAL_UDP_VERBOSE
            Log.Info($"baseClient initialized with ipEp:{bindAddress}.", "ConcurrentUdpClient");
#endif
            Task.Run(BackgroundUpdate);
        }

        public void Connect(IPEndPoint ipEp)
        {
            ConnectedAddress = ipEp;
#if SPECIAL_UDP_VERBOSE
            Log.Info($"baseClient Connected to ipEp:{ipEp}.", "ConcurrentUdpClient");
#endif
            baseClient.Connect(ipEp);
        }
        #endregion

        // 发送队列
        private ConcurrentQueue<UdpSendPacket> qSend = new();
        // 接收队列
        private ConcurrentQueue<UdpReceivePacket> qRecv = new();
        // 内部使用的UdpClient实例
        private UdpClient baseClient;
        public IPEndPoint? ConnectedAddress { get; set; }

        public int RefreshMilliseconds = 10;

        #region Receive Packet
        public byte[] Receive(ref IPEndPoint fromip)
        {
#if SPECIAL_UDP_VERBOSE
            Log.Info($"User tried to invoke Receive().", "ConcurrentUdpClient");
#endif
            var handle = new UdpReceivePacket(UdpInvoke.Receive);
            qRecv.Enqueue(handle);
            while (true)
            {
                if (handle.receiveData != null)
                {
#if SPECIAL_UDP_VERBOSE
                    Log.Info($"Successfully received {((UdpReceiveResult)handle.receiveData).Buffer.Length} bytes in Receive().", "ConcurrentUdpClient");
#endif
                    fromip = ((UdpReceiveResult)handle.receiveData).RemoteEndPoint;
                    return ((UdpReceiveResult)handle.receiveData).Buffer;
                }
                if (handle.ex != null) throw handle.ex;
                Task.Delay(RefreshMilliseconds).Wait();
            }
        }

        public async Task<UdpReceiveResult> ReceiveAsync()
        {
#if SPECIAL_UDP_VERBOSE
            Log.Info($"User tried to invoke ReceiveAsync().", "ConcurrentUdpClient");
#endif
            var handle = new UdpReceivePacket(UdpInvoke.Receive);
            qRecv.Enqueue(handle);
            while (true)
            {
                if (handle.receiveData != null)
                {
#if SPECIAL_UDP_VERBOSE
                    Log.Info($"Successfully received {((UdpReceiveResult)handle.receiveData).Buffer.Length} bytes in ReceiveAsync().", "ConcurrentUdpClient");
#endif
                    return (UdpReceiveResult)handle.receiveData;
                }
                if (handle.ex != null) throw handle.ex;
                await Task.Delay(RefreshMilliseconds);
            }
        }
        #endregion

        #region Send Packet
        public int Send(byte[] data, int? bytes = null, IPEndPoint? endpoint = null)
        {
#if SPECIAL_UDP_VERBOSE
            Log.Info($"User tried to invoke Send() with {data.Length} bytes to {endpoint}.", "ConcurrentUdpClient");
#endif
            if (endpoint == null && ConnectedAddress == null)
                // WSAENOTCONN, socket not connected
                throw new SocketException(10057);
            bytes ??= data.Length;
            var handle = new UdpSendPacket(data, (int)bytes, endpoint, 
                endpoint == null ? UdpInvoke.SendConnected : UdpInvoke.SendAnyEndpoint);
            qSend.Enqueue(handle);
            while (true)
            {
                if (handle.rtn != null)
                {
                    if (handle.ex != null)
                    {
#if SPECIAL_UDP_VERBOSE
                        Log.Dbug("Invoke Send() throwed an exception.", "ConcurrentUdpClient");
#endif
                        // 如果有异常则抛出
                        throw handle.ex;
                    }
#if SPECIAL_UDP_VERBOSE
                    Log.Dbug($"Invoke Send() returned {handle.rtn}.", "ConcurrentUdpClient");
#endif
                    return (int)handle.rtn;
                }
                Task.Delay(RefreshMilliseconds).Wait();
            }
        }

        public async Task<int> SendAsync(byte[] data, int? bytes = null, IPEndPoint? endpoint = null)
        {
#if SPECIAL_UDP_VERBOSE
            Log.Info($"User tried to invoke SendAsync() with {data.Length} bytes to {endpoint}.", "ConcurrentUdpClient");
#endif
            if (endpoint == null && ConnectedAddress == null)
                // WSAENOTCONN, socket not connected
                throw new SocketException(10057); 
            bytes ??= data.Length;
            var handle = new UdpSendPacket(data, (int)bytes, endpoint, 
                endpoint == null ? UdpInvoke.SendAsyncConnected : UdpInvoke.SendAsyncAnyEndpoint);
            qSend.Enqueue(handle);
            while (true)
            {
                if (handle.rtn != null)
                { 
                   if (handle.ex != null)
                    {
#if SPECIAL_UDP_VERBOSE
                        Log.Dbug("Invoke SendAsync() throwed an exception.", "ConcurrentUdpClient");
#endif
                        // 如果有异常则抛出
                        throw handle.ex;
                    }
#if SPECIAL_UDP_VERBOSE
                    Log.Dbug($"Invoke SendAsync() returned {handle.rtn}.", "ConcurrentUdpClient");
#endif
                    return (int)handle.rtn;
                }
                await Task.Delay(10);
            }
        }
        
        public async Task<int> SendAsync(ReadOnlyMemory<byte> data, IPEndPoint? endpoint = null)
        {
#if SPECIAL_UDP_VERBOSE
            Log.Info($"User tried to invoke SendAsync() with {data.Length} bytes to {endpoint}.", "ConcurrentUdpClient");
#endif
            if (endpoint == null && ConnectedAddress == null)
                // WSAENOTCONN, socket not connected
                throw new SocketException(10057);
            var handle = new UdpSendPacket(data, endpoint,
                endpoint == null ? UdpInvoke.SendAsyncMemoryConnected : UdpInvoke.SendAsyncMemoryAnyEndpoint);
            qSend.Enqueue(handle);
            while (true)
            {
                if (handle.rtn != null)
                {
                    if (handle.ex != null)
                    {
#if SPECIAL_UDP_VERBOSE
                        Log.Dbug("Invoke SendAsync() throwed an exception.", "ConcurrentUdpClient");
#endif
                        // 如果有异常则抛出
                        throw handle.ex;
                    }
#if SPECIAL_UDP_VERBOSE
                    Log.Dbug($"Invoke SendAsync() returned {handle.rtn}.", "ConcurrentUdpClient");
#endif
                    return (int)handle.rtn;
                }
                await Task.Delay(10);
            }
        }
        #endregion

        #region Background Handler
        // 后台更新任务
        private async Task BackgroundUpdate()
        {
            if (qSend.TryDequeue(out UdpSendPacket? sendpacket))
            {
#if SPECIAL_UDP_VERBOSE
                Stopwatch watch = new();
                bool exHappened = false;
                watch.Start();
#endif
                try
                {
                    // 发送数据
                    switch (sendpacket.invoke)
                    {
                        case UdpInvoke.SendConnected:
                            sendpacket.rtn = baseClient.Send(
                                sendpacket.data, (int)sendpacket.bytes);
                            break;
                        case UdpInvoke.SendAnyEndpoint:
                            sendpacket.rtn = baseClient.Send(
                                sendpacket.data, (int)sendpacket.bytes, sendpacket.endpoint);
                            break;
                        case UdpInvoke.SendAsyncConnected:
                            sendpacket.rtn = await baseClient.SendAsync(
                                sendpacket.data, (int)sendpacket.bytes);
                            break;
                        case UdpInvoke.SendAsyncAnyEndpoint:
                            sendpacket.rtn = await baseClient.SendAsync(
                                sendpacket.data, (int)sendpacket.bytes, sendpacket.endpoint);
                            break;
                        case UdpInvoke.SendAsyncMemoryConnected:
                            sendpacket.rtn = await baseClient.SendAsync(
                                (ReadOnlyMemory<byte>)sendpacket.memoryData);
                            break;
                        case UdpInvoke.SendAsyncMemoryAnyEndpoint:
                            sendpacket.rtn = await baseClient.SendAsync(
                                (ReadOnlyMemory<byte>)sendpacket.memoryData, sendpacket.endpoint);
                            break;
                        default:
                            Log.Erro($"Receive packet accidently ran into send queue," + 
                                $"Invoke:{sendpacket.invoke}, packet[{sendpacket.bytes}]:" +
                                Convert.ToHexString(sendpacket.data), "ConcurrentUdpClient");
                            break;
                    }
                }
                catch (Exception ex)
                {
                    sendpacket.ex = ex;
                    sendpacket.rtn = -1;
#if SPECIAL_UDP_VERBOSE
                    exHappened = true;
#endif
                }
#if SPECIAL_UDP_VERBOSE
                watch.Stop();
                Log.Dbug($"Handle qSend {(exHappened ? "(Exception)" : string.Empty)} " +
                    $"costed {watch.ElapsedMilliseconds}ms.", "ConcurrentUdpClient");
#endif
            }
            else if (baseClient.Available > 0
                && qRecv.TryPeek(out UdpReceivePacket? receivepacket))
            {
#if SPECIAL_UDP_VERBOSE
                Stopwatch watch = new();
                bool exHappened = false;
                bool timeout = false;
                watch.Start();
#endif
                switch (receivepacket.invoke)
                {
                    case UdpInvoke.Receive:
                        try
                        {
                            IPEndPoint ipEp = new(IPAddress.Loopback, 0);
#if SPECIAL_UDP_WARNING || SPECIAL_UDP_VERBOSE
                            Stopwatch cancelwatch = new();
                            cancelwatch.Start();
#endif
                            byte[] buf = baseClient.Receive(ref ipEp);
#if SPECIAL_UDP_WARNING || SPECIAL_UDP_VERBOSE
                            cancelwatch.Stop();
                            if (cancelwatch.ElapsedMilliseconds > 40)
                            {
                                Log.Warn("Syncronous Receive() stuck for " +
                                    $"{cancelwatch.ElapsedMilliseconds}ms!", "ConcurrentUdpClient");
#endif
#if SPECIAL_UDP_VERBOSE
                                timeout = true;
#endif
#if SPECIAL_UDP_WARNING || SPECIAL_UDP_VERBOSE
                            }
#endif
                            receivepacket.receiveData = new(buf, ipEp);
                            qRecv.TryDequeue(out _);
#if SPECIAL_UDP_VERBOSE
                            Log.Dbug($"Background qRecv handle received {buf.Length} bytes.", "ConcurrentUdpClient");
#endif
                        }
                        catch (Exception ex)
                        {
                            receivepacket.ex = ex;
                            qRecv.TryDequeue(out _);
#if SPECIAL_UDP_VERBOSE
                            exHappened = true;
#endif
                        }
                        break;
                    case UdpInvoke.ReceiveAsync:
                        var cancellationTokenSource = new CancellationTokenSource();
                        var captureToken = cancellationTokenSource.Token;
                        try
                        { 
                            cancellationTokenSource.CancelAfter(50);                                
                            UdpReceiveResult res = await baseClient.ReceiveAsync(captureToken);
                            receivepacket.receiveData = res;
                            qRecv.TryDequeue(out _);
#if SPECIAL_UDP_VERBOSE
                            Log.Dbug($"Background qRecv handle(async) received {res.Buffer.Length} bytes.", "ConcurrentUdpClient");
#endif
                        }
                        catch (OperationCanceledException)
                        { 
#if SPECIAL_UDP_WARNING || SPECIAL_UDP_VERBOSE
                            Log.Warn("Asyncronous ReceiveAsync() timeout of 50ms and canceled!", "ConcurrentUdpClient");
#endif
#if SPECIAL_UDP_VERBOSE
                            timeout = true;
#endif
                        }
                        catch (Exception ex)
                        {
                            receivepacket.ex = ex;
                            qRecv.TryDequeue(out _);
#if SPECIAL_UDP_VERBOSE
                            exHappened = true;
#endif
                        }
                        break;
                    default:
                        Log.Erro("Send packet accidently ran into receive queue," + 
                            $"Invoke:{receivepacket.invoke}", "ConcurrentUdpClient");
                        qRecv.TryDequeue(out _);
                        break;
                }
#if SPECIAL_UDP_VERBOSE
                watch.Stop();
                Log.Dbug($"Handle qRecv {(exHappened ? "(Exception)" : string.Empty)} " +
                    $"costed {watch.ElapsedMilliseconds}ms." +
                    (timeout ? " (timed out) " : string.Empty), "ConcurrentUdpClient");
#endif
            }
            else
            {
                // 等待一段时间，降低CPU占用
                await Task.Delay(5);
            }
            await Task.Run(BackgroundUpdate);
        }
        #endregion

        #region IDisposeable
        /* Generated by ChatGPT
         * 在上面的代码中，我们实现了Close()、Dispose()和Protected Dispose(bool)方法，并且实现了IDisposeable接口。
         * 它们的作用如下：

         * - Close()方法：关闭基础UDP客户端。
         * - Dispose()方法：释放托管资源和非托管资源。
         *   这个方法由垃圾回收器调用，也可以由开发人员主动调用。
         *   在这里，我们在调用Dispose()方法时通过调用Dispose(true)方法释放托管资源，
         *   并抑制GC.SuppressFinalize(this)来防止使用Finalizer。
         * - Protected Dispose(bool)方法：释放非托管资源。
         *   如果disposing为true，则还会释放托管资源。

         * 需要注意的是，我们在类定义中还定义了一个Finalizer（也就是析构函数）。
         * 这个Finalizer中调用了Dispose(false)方法，以释放非托管资源。
         * 这样做是为了确保即使开发人员没有调用Dispose()方法，也能在对象被垃圾回收前释放非托管资源。
         */
        public void Close()
        {
            baseClient.Close();
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (baseClient != null)
                {
                    baseClient.Dispose();
                    baseClient = null;
                }
            }
        }

        ~ConcurrentUdpClient()
        {
            Dispose(false);
        }
        #endregion
    }
}

#pragma warning restore CS8604 // 引用类型参数可能为 null。
#pragma warning restore CS8629 // 可为 null 的值类型可为 null。
#pragma warning restore CS8625 // 无法将 null 字面量转换为非 null 的引用类型。