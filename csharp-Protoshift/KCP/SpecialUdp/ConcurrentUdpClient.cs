// Generated by ChatGPT
#define SPECIAL_UDP_VERBOSE
#define SPECIAL_UDP_WARNING

using System;
using System.Collections.Concurrent;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using YYHEggEgg.Logger;

namespace csharp_Protoshift.SpecialUdp
{
    public sealed class ConcurrentUdpClient : IDisposable
    {
        #region Packet Utils
        private enum UdpInvoke
        {
            /// <summary>
            /// Equal to <see cref="UdpClient.Send(byte[], int)"/>.
            /// </summary>
            SendConnected = 1,
            /// <summary>
            /// Equal to <see cref="UdpClient.Send(byte[], int, IPEndPoint)"/>.
            /// </summary>
            SendAnyEndpoint = 2,
            /// <summary>
            /// Equal to <see cref="UdpClient.SendAsync(byte[], int)"/>.
            /// </summary>
            SendAsyncConnected = 11,
            /// <summary>
            /// Equal to <see cref="UdpClient.SendAsync(byte[], int, IPEndPoint)"/>.
            /// </summary>
            SendAsyncAnyEndpoint = 12,
            /// <summary>
            /// Equal to <see cref="UdpClient.Receive(IPEndPoint)"/>.
            /// </summary>
            Receive = 101,
            /// <summary>
            /// Equal to <see cref="UdpClient.ReceiveAsync()"/>.
            /// </summary>
            ReceiveAsync = 111
        }

        private class UdpSendPacket
        {
            public byte[] data;
            public int bytes;
            public IPEndPoint? endpoint;
            public Exception? ex;
            public int? rtn;
            public UdpInvoke invoke;

            public UdpSendPacket(byte[] data, int bytes, IPEndPoint? endpoint, UdpInvoke invoke)
            {
                this.data = data;
                this.bytes = bytes;
                this.endpoint = endpoint;
                this.invoke = invoke;
            }
        }

        private class UdpReceivePacket
        {
            public UdpReceiveResult? receiveData;
            public Exception? ex;
            public UdpInvoke invoke;

            public UdpReceiveResult(UdpInvoke invoke)
            {
                this.invoke = invoke;
            }
        }
        #endregion

        #region BeforeHand Initialize
        // 构造函数
        public ConcurrentUdpClient()
        {
            // 初始化UdpClient实例
            baseClient = new UdpClient();
            // 启动后台更新任务
            Task.Run(BackgroundUpdate);
        }

        public ConcurrentUdpClient(IPEndPoint bindAddress)
        {
            baseClient = new UdpClient(bindAddress);
            Task.Run(BackgroundUpdate);
        }

        public void Connect(IPEndPoint ipEp)
        {
            ConnectedAddress = ipEp;
            baseClient.Connect(ipEp);
        }
        #endregion

        // 发送队列
        private ConcurrentQueue<UdpSendPacket> qSend = new();
        // 接收队列
        private ConcurrentQueue<UdpReceivePacket> qRecv = new();
        // 内部使用的UdpClient实例
        private UdpClient baseClient;
        public IPEndPoint? ConnectedAddress { get; set; }

        public int RefreshMilliseconds = 10;

        #region Receive Packet
        public byte[] Receive(ref IPEndPoint fromip)
        {
            var handle = new UdpReceivePacket(UdpInvoke.Receive);
            qRecv.Enqueue(handle);
            while (true)
            {
                if (handle.receiveData != null)
                {
                    fromip = handle.receiveData.RemoteEndPoing;
                    return handle.receiveData.Buffer;
                }
                if (handle.ex != null) throw handle.ex;
                Task.Delay(RefreshMilliseconds).Wait();
            }
        }

        public async Task<UdpReceiveResult> ReceiveAsync()
        {
            var handle = new UdpReceivePacket(UdpInvoke.Receive);
            qRecv.Enqueue(handle);
            while (true)
            {
                if (handle.receiveData != null) return handle.receiveData;
                if (handle.ex != null) throw handle.ex;
                await Task.Delay(RefreshMilliseconds);
            }
        }
        #endregion

        #region Send Packet
        public int Send(byte[] data, int? bytes = null, IPEndPoint? endpoint = null)
        {
            if (endpoint == null && ConnectedAddress == null)
                // WSAENOTCONN, socket not connected
                throw new SocketException(10057); 
            bytes ??= data.Length;
            var handle = new UdpSendPacket(data, bytes, endpoint, 
                endpoint == null ? UdpInvoke.SendConnected : UdpInvoke.SendAnyEndpoint);
            qSend.Enqueue(handle);
            while (true)
            {
                if (handle.rtn != null)
                {
                    if (handle.ex != null)
                    {
                        // 如果有异常则抛出
                        throw handle.ex;
                    }
                    return (int)handle.rtn;
                }
                Task.Delay(RefreshMilliseconds).Wait();
            }
        }

        public async Task<int> SendAsync(byte[] data, int? bytes = null, IPEndPoint? endpoint = null)
        {
            if (endpoint == null && ConnectedAddress == null)
                // WSAENOTCONN, socket not connected
                throw new SocketException(10057); 
            bytes ??= data.Length;
            var handle = new UdpSendPacket(data, bytes, endpoint, 
                endpoint == null ? UdpInvoke.SendConnected : UdpInvoke.SendAnyEndpoint);
            qSend.Enqueue(handle);
            while (true)
            {
                if (handle.rtn != null)
                {
                    if (handle.ex != null)
                    {
                        // 如果有异常则抛出
                        throw handle.ex;
                    }
                    return (int)handle.rtn;
                }
                await Task.Delay(10);
            }
        }
        #endregion

        #region Background Handler
        // 后台更新任务
        private async Task BackgroundUpdate()
        {
            if (qSend.TryDequeue(out UdpSendPacket sendpacket))
            {
#if SPECIAL_UDP_VERBOSE
                StopWatch watch = new();
                bool exHappened = false;
                watch.Start();
#endif
                try
                {
                    // 发送数据
                    switch (sendpacket.invoke)
                    {
                        case UdpInvoke.SendConnected:
                            sendpacket.rtn = baseClient.Send(
                                sendpacket.data, sendpacket.bytes);
                            break;
                        case UdpInvoke.SendAnyEndpoint:
                            sendpacket.rtn = baseClient.Send(
                                sendpacket.data, sendpacket.bytes, sendpacket.endpoint);
                            break;
                        case UdpInvoke.SendAsyncConnected:
                            sendpacket.rtn = await baseClient.SendAsync(
                                sendpacket.data, sendpacket.bytes);
                            break;
                        case UdpInvoke.SendAsyncAnyEndpoint:
                            sendpacket.rtn = await baseClient.SendAsync(
                                sendpacket.data, sendpacket.bytes, sendpacket.endpoint);
                            break;
                        default:
                            Log.Erro($"Receive packet accidently ran into send queue," + 
                                $"Invoke:{sendpacket.invoke}, packet[{sendpacket.bytes}]:" +
                                Convert.ToHexString(sendpacket.data), "ConcurrentUdpClient");
                            break;
                    }
                }
                catch (Exception ex)
                {
                    sendpacket.ex = ex;
                    sendpacket.rtn = -1;
#if SPECIAL_UDP_VERBOSE
                    exHappened = true;
#endif
                }
#if SPECIAL_UDP_VERBOSE
                watch.End();
                Log.Dbug($"Handle qSend {(exHappened ? "(Exception)" : string.Empty)} " +
                    $"costed {watch.ElapsedMilliseconds}ms.", "ConcurrentUdpClient");
#endif
            }
            else if (baseClient.Available > 0
                && qRecv.TryPeek(out UdpReceivePacket receivepacket))
            {
#if SPECIAL_UDP_VERBOSE
                StopWatch watch = new();
                bool exHappened = false;
                bool timeout = false;
                watch.Start();
#endif
                // 接收数据
                UdpReceiveResult result;
                switch (receivepacket.invoke)
                {
                    case UdpInvoke.Receive:
                        try
                        {
                            IPEndPoint ipEp;
#if SPECIAL_UDP_WARNING | SPECIAL_UDP_VERBOSE
                            StopWatch cancelwatch = new();
                            cancelwatch.Start();
#endif
                            byte[] buf = result.Receive(ref ipEp);
#if SPECIAL_UDP_WARNING | SPECIAL_UDP_VERBOSE
                            cancelwatch.End();
                            if (cancelwatch.ElapsedMilliseconds > 40)
                            {
                                Log.Warn("Syncronous Receive() stuck for " +
                                    $"{watch.ElapsedMilliseconds}ms!", "ConcurrentUdpClient");
#endif
#if SPECIAL_UDP_VERBOSE
                                timeout = true;
#endif
#if SPECIAL_UDP_WARNING | SPECIAL_UDP_VERBOSE
                            }
#endif
                            receivepacket.receiveData = new(buf, ipEp);
                        }
                        catch (Exception ex)
                        {
                            receivepacket.ex = ex;
#if SPECIAL_UDP_VERBOSE
                            exHappened = true;
#endif
                        }
                        break;
                    case UdpInvoke.ReceiveAsync:
                        var cancellationTokenSource = new CancellationTokenSource();
                        var captureToken = cancellationTokenSource.Token;
                        try
                        { 
                            cancellationTokenSource.CancelAfter(50);                                UdpReceiveResult res = await baseClient.ReceiveAsync(captureToken);
                            receivepacket.receiveData = res;
                        }
                        catch (OperationCanceledException)
                        { 
#if SPECIAL_UDP_WARNING | SPECIAL_UDP_VERBOSE
                            Log.Warn("Asyncronous ReceiveAsync() timeout of 50ms and canceled!", "ConcurrentUdpClient");
                            timeout = true;
#endif
                        }
                        catch (Exception ex)
                        {
                            receivepacket.ex = ex;
#if SPECIAL_UDP_VERBOSE
                            exHappened = true;
#endif
                        }
                        break;
                    default:
                        Log.Erro("Send packet accidently ran into receive queue," + 
                            $"Invoke:{receivepacket.invoke}", "ConcurrentUdpClient");
                        break;
                }
#if SPECIAL_UDP_VERBOSE
                watch.End();
                Log.Dbug($"Handle qRecv {(exHappened ? "(Exception)" : string.Empty)} " +
                    $"costed {watch.ElapsedMilliseconds}ms." +
                    (timeout ? " (timed out) " : string.Empty), "ConcurrentUdpClient");
#endif
            }
            else
            {
                // 等待一段时间，降低CPU占用
                await Task.Delay(5);
            }
            await Task.Run(BackgroundUpdate);
        }
        #endregion

        #region IDisposeable
        /* Generated by ChatGPT
         * 在上面的代码中，我们实现了Close()、Dispose()和Protected Dispose(bool)方法，并且实现了IDisposeable接口。
         * 它们的作用如下：

         * - Close()方法：关闭基础UDP客户端。
         * - Dispose()方法：释放托管资源和非托管资源。
         *   这个方法由垃圾回收器调用，也可以由开发人员主动调用。
         *   在这里，我们在调用Dispose()方法时通过调用Dispose(true)方法释放托管资源，
         *   并抑制GC.SuppressFinalize(this)来防止使用Finalizer。
         * - Protected Dispose(bool)方法：释放非托管资源。
         *   如果disposing为true，则还会释放托管资源。

         * 需要注意的是，我们在类定义中还定义了一个Finalizer（也就是析构函数）。
         * 这个Finalizer中调用了Dispose(false)方法，以释放非托管资源。
         * 这样做是为了确保即使开发人员没有调用Dispose()方法，也能在对象被垃圾回收前释放非托管资源。
         */
        public void Close()
        {
            baseClient.Close();
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (baseClient != null)
                {
                    baseClient.Dispose();
                    baseClient = null;
                }
            }
        }

        ~ConcurrentUdpClient()
        {
            Dispose(false);
        }
        #endregion
    }
}