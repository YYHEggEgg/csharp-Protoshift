using System.Collections.ObjectModel;
using System.Diagnostics;
using YYHEggEgg.Logger;

namespace csharp_Protoshift.Enhanced.Handlers.Generator
{
    public partial class ProtocStringPoolManager
    {
        #region String Pool file related
        private StreamWriter[] files;
        public ProtocStringPoolManager()
        {
            Directory.CreateDirectory($"{Environment.CurrentDirectory}/ProtoFieldNameAnalyze/GeneratedProtos");
            Directory.CreateDirectory($"{Environment.CurrentDirectory}/ProtoFieldNameAnalyze/Compiled");
            files = new StreamWriter[3]
            {
                new($"{Environment.CurrentDirectory}/ProtoFieldNameAnalyze/GeneratedProtos/StringPool1.proto"),
                new($"{Environment.CurrentDirectory}/ProtoFieldNameAnalyze/GeneratedProtos/StringPool2.proto"),
                new($"{Environment.CurrentDirectory}/ProtoFieldNameAnalyze/GeneratedProtos/StringPool3.proto")
            };
            WriteLine("syntax = \"proto3\";");
            files[0].WriteLine("enum StringPool1 { ");
            files[1].WriteLine("enum StringPool2 { ");
            files[2].WriteLine("enum StringPool3 { ");
            WriteLine("    option allow_alias = true;");
            WriteLine("    Identifier = 0;");
            WriteLine("    iDentifier = 0;");
        }
        private void WriteLine()
        {
            foreach (var writer in files)
            {
                writer.WriteLine();
            }
        }
        private void WriteLine(string content)
        {
            foreach (var writer in files)
            {
                writer.WriteLine(content);
            }
        }
        private void SaveFiles()
        {
            foreach (var writer in files)
            {
                writer.Flush();
                writer.Dispose();
            }
        }
        #endregion

        private bool compiled; // Whether Compile() has been invoked
        private bool compilingFailed;
        private object pushLock = "Ast Rickley";
        private SortedSet<string> names = new();
        private ReadOnlyDictionary<string, string> originalToCompiledDict;

        // private const string Compiled_IdentifierLine = "[pbr::OriginalName(\"Identifier\")] Identifier = 0,";
        private const string Compiled_IdentifierLine = "[pbr::OriginalName(\"iDentifier\", PreferredAlias = false)] IDentifier = 0,";
        private const string Compiled_AttributePrefix = "[pbr::OriginalName(\"";
        private const string Compiled_AttributeSuffix = "\")] ";
        private const string Compiled_AttributeSuffix_IsAlias = "\", PreferredAlias = false)] ";
        private const string Compiled_EnumValuePrefix = " = ";

        #region Forbidden names
        ReadOnlyDictionary<string, string> forbiddenNames = new(new Dictionary<string, string>
        {
            { "option", "Option" },
            { "Identifier", "Identifier" },
            { "iDentifier", "IDentifier" }
        });
        #endregion

        // Corner Case:
        // ABCDEFG -> Abcdefg in enum grammar,
        // but ABCDEFG -> ABCDEFG in message grammar
        private string UpperCornerCaseSolve(string inputString)
        {
            // Generated by ChatGPT
            return string.Concat(inputString.Select(c => char.IsUpper(c) ? "_" + c : c.ToString()));
        }

        /// <summary>
        /// Push a field name to string pool. Invoke before <see cref="Compile()"/>.
        /// </summary>
        public void PushFieldName(string originalName)
        {
            if (compiled)
                throw new InvalidOperationException("StringPool has compiled and don't accept any new field names.");
            var changedName = UpperCornerCaseSolve(originalName);
            if (!forbiddenNames.ContainsKey(originalName))
            {
                lock (pushLock)
                {
                    names.Add(changedName);
                }
            }
        }

        /// <summary>
        /// Compile the string pool and make it read-only.
        /// </summary>
        /// <exception cref="InvalidOperationException">Compile for this instance is no longer avaliable.</exception>
        /// <exception cref="ApplicationException">protoc Compiling failed.</exception>
        public async Task Compile()
        {
            #region Assert
            if (compilingFailed)
                throw new InvalidOperationException("The instance has failed to compile and not avaliable any more.");
            if (compiled)
                throw new InvalidOperationException("StringPool has compiled and can't compile twice.");
            compiled = true;
            #endregion
            #region Write StringPool
            var namelist = names.ToArray();
            for (int i = 0; i < namelist.Length; i++)
            {
                WriteLine($"    {namelist[i]} = {i};");
            }
            WriteLine("}");
            Log.Info($"StringPool started compiling, {namelist.Length} fields detected.", nameof(ProtocStringPoolManager));
            #endregion
            SaveFiles();

            #region Invoke protoc
            await InvokeProtocAsync("StringPool1");
            await InvokeProtocAsync("StringPool2");
            await InvokeProtocAsync("StringPool3");
            #endregion
            Dictionary<string, string> _compiledNameDict = new();
            Dictionary<string, string?> _possibleCompiledNameDict = new();
            #region Analyze compiled file
            using (StreamReader reader1 = new($"{Environment.CurrentDirectory}/ProtoFieldNameAnalyze/Compiled/StringPool1.cs"))
            {
                bool reachedPoolDataRegion = false;
                long currentLine = 0;
                while (!reader1.EndOfStream)
                {
                    #region Data Region Manage
                    currentLine++;
                    string? line = (await reader1.ReadLineAsync())?.Trim();
                    if (!reachedPoolDataRegion)
                    {
                        if (line == Compiled_IdentifierLine)
                        {
                            Log.Verb($"Reached identifier at line {currentLine}.", nameof(ProtocStringPoolManager));
                            reachedPoolDataRegion = true;
                        }
                        continue;
                    }
                    if (line == null) continue;
                    if (!line.StartsWith(Compiled_AttributePrefix))
                    {
                        Log.Verb($"End of Data Region at line {currentLine}.", nameof(ProtocStringPoolManager));
                        break;
                    }
                    #endregion
                    var res = ReadValueFromCompiledFileLine(line, namelist);
                    _compiledNameDict.Add(res.originalName, res.compiledName);
                    _possibleCompiledNameDict.Add(res.originalName, null);
                }
            }
            Log.Info($"StringPool1.cs analyze finished.", nameof(ProtocStringPoolManager));
            using (StreamReader reader2 = new($"{Environment.CurrentDirectory}/ProtoFieldNameAnalyze/Compiled/StringPool2.cs"))
            {
                bool reachedPoolDataRegion = false;
                long currentLine = 0;
                while (!reader2.EndOfStream)
                {
                    #region Data Region Manage
                    currentLine++;
                    string? line = (await reader2.ReadLineAsync())?.Trim();
                    if (!reachedPoolDataRegion)
                    {
                        if (line == Compiled_IdentifierLine)
                        {
                            Log.Verb($"Reached identifier at line {currentLine}.", nameof(ProtocStringPoolManager));
                            reachedPoolDataRegion = true;
                        }
                        continue;
                    }
                    if (line == null) continue;
                    if (!line.StartsWith(Compiled_AttributePrefix))
                    {
                        Log.Verb($"End of Data Region at line {currentLine}.", nameof(ProtocStringPoolManager));
                        break;
                    }
                    #endregion
                    var res = ReadValueFromCompiledFileLine(line, namelist);
                    if (_compiledNameDict.ContainsKey(res.originalName))
                    {
                        if (_compiledNameDict[res.originalName] != res.compiledName)
                        {
                            _possibleCompiledNameDict[res.originalName] = res.compiledName;
                        }
                    }
                    else
                    {
                        Log.Dbug($"Field detected in StringPool2 but not in StringPool1, " +
                            $"originalName: {res.originalName}, compiledName: {res.compiledName}", nameof(ProtocStringPoolManager));
                        _compiledNameDict.Add(res.originalName, res.compiledName);
                        _possibleCompiledNameDict.Add(res.originalName, null);
                    }
                }
            }
            Log.Info($"StringPool2.cs analyze finished.", nameof(ProtocStringPoolManager));
            using (StreamReader reader3 = new($"{Environment.CurrentDirectory}/ProtoFieldNameAnalyze/Compiled/StringPool3.cs"))
            {
                bool reachedPoolDataRegion = false;
                long currentLine = 0;
                while (!reader3.EndOfStream)
                {
                    #region Data Region Manage
                    currentLine++;
                    string? line = (await reader3.ReadLineAsync())?.Trim();
                    if (!reachedPoolDataRegion)
                    {
                        if (line == Compiled_IdentifierLine)
                        {
                            Log.Verb($"Reached identifier at line {currentLine}.", nameof(ProtocStringPoolManager));
                            reachedPoolDataRegion = true;
                        }
                        continue;
                    }
                    if (line == null) continue;
                    if (!line.StartsWith(Compiled_AttributePrefix))
                    {
                        Log.Verb($"End of Data Region at line {currentLine}.", nameof(ProtocStringPoolManager));
                        break;
                    }
                    #endregion
                    var res = ReadValueFromCompiledFileLine(line, namelist);
                    if (_compiledNameDict.ContainsKey(res.originalName))
                    {
                        // res.compiledName is not null, possibleName == res.compiledName, so possibleName not null
                        if (_possibleCompiledNameDict[res.originalName] == res.compiledName)
                        {
                            _compiledNameDict[res.originalName] =
                                (string)_possibleCompiledNameDict[res.originalName];
                        }
                    }
                    else
                    {
                        Log.Dbug($"Field detected in StringPool3 but not in StringPool1&2, " +
                            $"originalName: {res.originalName}, compiledName: {res.compiledName}", nameof(ProtocStringPoolManager));
                        _compiledNameDict.Add(res.originalName, res.compiledName);
                        _possibleCompiledNameDict.Add(res.originalName, null);
                    }
                }
            }
            Log.Info($"StringPool3.cs analyze finished.", nameof(ProtocStringPoolManager));
            #endregion
            #region Add forbidden names in protoc
            foreach (var pair in forbiddenNames)
            {
                _compiledNameDict.Add(pair.Key, pair.Value);
            }
            #endregion
            originalToCompiledDict = new(_compiledNameDict);

            #region Invoke protoc command
            async Task InvokeProtocAsync(string protoname)
            {
                string commandLine = string.Concat(
                    "--proto_path=\"", Environment.CurrentDirectory, "/ProtoFieldNameAnalyze/GeneratedProtos\" ",
                    "\"", Environment.CurrentDirectory, "/ProtoFieldNameAnalyze/GeneratedProtos/", protoname, ".proto\" ",
                    "--csharp_out=\"", Environment.CurrentDirectory, "/ProtoFieldNameAnalyze/Compiled\""
                );
                Stopwatch watch = Stopwatch.StartNew();
                Process p = Process.Start(OuterInvokeConfig.protoc_path, commandLine);
                Log.Verb($"Started invoking protoc: protoc {commandLine}", nameof(ProtocStringPoolManager));
                await p.WaitForExitAsync();
                watch.Stop();
                Log.Info($"protoc invoke exited, costed {watch.Elapsed}.", nameof(ProtocStringPoolManager));
                if (p.ExitCode != 0)
                {
                    Log.Erro($"protoc compiling exited with code {p.ExitCode}. Compiling Failed. ", nameof(ProtocStringPoolManager));
                    compilingFailed = true;
                    throw new ApplicationException($"protoc compiling exited with code {p.ExitCode}. Compiling Failed. ");
                }
            }
            #endregion
        }

        private (string originalName, string compiledName)
            ReadValueFromCompiledFileLine(string line, string[] namelist)
        {
            #region Read original name
            int indexEndOriginalName = line.IndexOf('"', Compiled_AttributePrefix.Length);
            string originalName = line.Substring(
                Compiled_AttributePrefix.Length, indexEndOriginalName - Compiled_AttributePrefix.Length);
            #endregion
            #region Read Compiled name
            #region Judge IsAlias
            bool isAlias = line.IndexOf(Compiled_AttributeSuffix_IsAlias, indexEndOriginalName) != -1;
            #endregion
            int indexStartCompiledName = indexEndOriginalName +
                (isAlias ? Compiled_AttributeSuffix_IsAlias : Compiled_AttributeSuffix).Length;
            int indexEndCompiledName = line.IndexOf(
                Compiled_EnumValuePrefix, indexStartCompiledName);
            string compiledName = line.Substring(
                indexStartCompiledName, indexEndCompiledName - indexStartCompiledName);
            #endregion
            #region Read value & verify
            int indexStartEnumValue = indexEndCompiledName + Compiled_EnumValuePrefix.Length;
            int enumValue = int.Parse(line.Substring(indexStartEnumValue,
                line.IndexOf(',', indexStartCompiledName) - indexStartEnumValue));
            if (namelist[enumValue] != originalName)
            {
                Log.Dbug($"Read enum value verify failed, " +
                    $"expected originalName: {namelist[enumValue]}, " +
                    $"read originalName: {originalName}, compiledName: {compiledName}, enumValue: {enumValue}",
                    nameof(ProtocStringPoolManager));
            }
            #endregion
            return (originalName, compiledName);
        }

        /// <summary>
        /// Get Compiled name from original protobuf field name. return null if not found. 
        /// </summary>
        public string? GetCompiledName(string fieldName)
        {
            if (!compiled)
                throw new InvalidOperationException("StringPool hasn't compiled and don't know the compiled name.");
            var changedName = UpperCornerCaseSolve(fieldName);
            if (originalToCompiledDict.TryGetValue(changedName, out string? rtn))
                return rtn;
            else return null;
        }

        // Canceled for inner data structure chaos.
        /*public ReadOnlyDictionary<string, string> GetAllNames()
        {
            if (!compiled)
                throw new InvalidOperationException("StringPool hasn't compiled and don't know the compiled name.");
            return originalToCompiledDict;
        }*/
    }

    public class CompiledEnumStringPoolManager
    {
        private ReadOnlyDictionary<string, string> originalToCompiledDict;

        private const string Compiled_AttributePrefix = "[pbr::OriginalName(\"";
        private const string Compiled_AttributeSuffix = "\")] ";
        private const string Compiled_AttributeSuffix_IsAlias = "\", PreferredAlias = false)] ";
        private const string Compiled_EnumValuePrefix = " = ";

        /// <summary>
        /// Initialize the StringPool map with a compiled enum code.
        /// </summary>
        /// <param name="compiled_enumproto_path">The compiled protobuf .cs file path.</param>
        /// <param name="start_lineNumber">The line that starts with <c>public enum</c>. Number starts with 1.</param>
        /// <param name="end_lineNumber">The line that contains a <c>}</c>. Number starts with 1.</param>
        /// <exception cref="ArgumentException">Compiled file part don't have the same enum record count as given.</exception>
        public CompiledEnumStringPoolManager(string[] compiled_enumproto_lines,
            int start_lineNumber, int end_lineNumber)
        {
            Dictionary<string, string> _compiledNameDict = new();
            #region Analyze compiled file
            for (int currentLine = start_lineNumber; currentLine <= end_lineNumber; currentLine++)
            {
                int arr_index = currentLine - 1;
                bool reachedPoolDataRegion = false;
                #region Data Region Manage
                if (currentLine < start_lineNumber || currentLine > end_lineNumber) continue;
                string? line = compiled_enumproto_lines[arr_index].Trim();
                if (line == null) continue;
                if (!reachedPoolDataRegion)
                {
                    if (!line.StartsWith(Compiled_AttributePrefix)) continue;
                    else
                    {
                        Log.Verb($"Reached Data Region at line {currentLine}.", nameof(CompiledEnumStringPoolManager));
                        reachedPoolDataRegion = true;
                    }
                }
                if (!line.StartsWith(Compiled_AttributePrefix))
                {
                    Log.Verb($"End of Data Region at line {currentLine}.", nameof(CompiledEnumStringPoolManager));
                    break;
                }
                #endregion
                var res = ReadValueFromCompiledFileLine(line);
                _compiledNameDict.Add(res.originalName, res.compiledName);
            }
            #endregion

            originalToCompiledDict = new(_compiledNameDict);
        }

        private (string originalName, string compiledName)
            ReadValueFromCompiledFileLine(string line)
        {
            #region Read original name
            int indexEndOriginalName = line.IndexOf('"', Compiled_AttributePrefix.Length);
            string originalName = line.Substring(
                Compiled_AttributePrefix.Length, indexEndOriginalName - Compiled_AttributePrefix.Length);
            #endregion
            #region Read Compiled name
            #region Judge IsAlias
            bool isAlias = line.IndexOf(Compiled_AttributeSuffix_IsAlias, indexEndOriginalName) != -1;
            #endregion
            int indexStartCompiledName = indexEndOriginalName +
                (isAlias ? Compiled_AttributeSuffix_IsAlias : Compiled_AttributeSuffix).Length;
            int indexEndCompiledName = line.IndexOf(
                Compiled_EnumValuePrefix, indexStartCompiledName);
            string compiledName = line.Substring(
                indexStartCompiledName, indexEndCompiledName - indexStartCompiledName);
            #endregion
            return (originalName, compiledName);
        }

        /// <summary>
        /// Get Compiled name from original protobuf field name. return null if not found. 
        /// </summary>
        public string? GetCompiledName(string fieldName)
        {
            if (originalToCompiledDict.TryGetValue(fieldName, out string? rtn))
                return rtn;
            else return null;
        }
    }

    public class CompiledEnumsStringPoolCollection
    {
        private Dictionary<string, CompiledEnumStringPoolManager> collection = new();

        /// <summary>
        /// Query a string pool with compiled enum name.
        /// </summary>
        /// <param name="compiled_name">The compiled name, can be identified with C# compiler but without namespace.</param>
        /// <returns></returns>
        public CompiledEnumStringPoolManager Query(string compiled_name)
        {
            return collection[compiled_name];
        }

        public void AddCodeFile(string code_fullPath)
        {
            string codefile_content = File.ReadAllText(code_fullPath);
            // not using Environment.NewLine here
            // maybe the code is generated LF and the platform provides CRLF
            var lines = codefile_content.Split('\n');
            CodeTree fullTree = CodeTreeBuilder.Build(codefile_content);
            var enumCodes = fullTree.GetPathsByType(CodeTreeQueryType.Enum);
            foreach (var enumCode in enumCodes)
            {
                collection.Add(enumCode.FullPath,
                    new(lines, enumCode.StartLine, enumCode.EndLine));
            }
        }
    }
}