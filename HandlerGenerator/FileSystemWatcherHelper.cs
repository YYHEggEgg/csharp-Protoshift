// Generated by ChatGPT
// prompt:
// 在 Visual Studio 中编译程序时，如果代码发生了改变，Visual Studio 会对相应的项目进行重新生成；
// 否则，它不会重复生成，而会提示项目“最新”。  
// Visual Studio会保留最后一次生成的时间戳，如果代码文件的时间戳发生改变，即代码被修改，则Visual Studio会识别出这个变化，触发重新生成。  
// 现在请你写一个 C# 类，实现与其相似的功能，即监控特定的文件夹中的内容是否自上次监视发生改变，主要基于以下实现方式：

// - 包含一个无参构造器。
// - 开放 `CaptureDirectory` 方法，记录文件夹中的各个文件状态，包括修改时间、大小等。
// - 开放 `SerializeToJson` 方法，返回一个 Json 字符串，记录当前的状态。它必须可以被反序列化。
// - 开放 `NeedRebuild { get; private set; }` 属性，从无参构造器中构造时默认为 true。
// - 开放 `DeserializeFromJson` **静态**方法，要求一个字符串参数 `string json`，
//   可反序列化由上面 `SerializeToJson` 方法生成的 Json 字符串。
//   注意，反序列化并不意味着返回的实例记录的文件状态与 json 中记录的相同；
//   返回实例时，当前正在监视的文件夹列表与 json 中记录的相同，
//   但**禁止 json 中记录的文件状态数据进入返回实例的数据**；
//   返回实例记录的文件状态永远是最新的，从 Json 中获取的数据只是过去记录的文件状态，只用于判断 `NeedRebuild`。
//   也就是说，上述条件只在 `DeserializeFromJson` 方法中判断，
//   如果过去的文件状态与现在的完全相同，则将 `NeedRebuild` 设为 false，然后将实例返回至用户。

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Newtonsoft.Json;

namespace FileSystemWatcherDemo
{
    public class FileSystemWatcherHelper
    {
        private readonly DirectoryInfo _directoryInfo;
        private readonly Dictionary<string, FileSystemInfo> _files;

        public FileSystemWatcherHelper()
        {
            _files = new Dictionary<string, FileSystemInfo>();
            NeedRebuild = true;
        }

        public FileSystemWatcherHelper(string directoryPath) : this()
        {
            SetDirectory(directoryPath);
        }

        public bool NeedRebuild { get; private set; }

        public void CaptureDirectory()
        {
            foreach (var fileInfo in _directoryInfo.EnumerateFileSystemInfos())
            {
                if (!_files.ContainsKey(fileInfo.FullName))
                {
                    _files.Add(fileInfo.FullName, fileInfo);
                    NeedRebuild = true;
                }
                else
                {
                    if (_files[fileInfo.FullName].LastWriteTime != fileInfo.LastWriteTime ||
                        _files[fileInfo.FullName].Length != fileInfo.Length)
                    {
                        _files[fileInfo.FullName] = fileInfo;
                        NeedRebuild = true;
                    }
                }
            }
        }

        public void SetDirectory(string directoryPath)
        {
            if (!Directory.Exists(directoryPath)) throw new ArgumentException("Directory doesn't exist.");

            _directoryInfo = new DirectoryInfo(directoryPath);
        }

        public string SerializeToJson()
        {
            var fileInfos = _files.Values.Select(s => new { s.Name, s.CreationTimeUtc, s.LastWriteTimeUtc, s.Length }).ToList();
            var result = JsonConvert.SerializeObject(new { Directory = _directoryInfo.FullName, FileInfos = fileInfos });
            return result;
        }

        public static FileSystemWatcherHelper DeserializeFromJson(string json)
        {
            var data = JsonConvert.DeserializeAnonymousType(json, new { Directory = "", FileInfos = new[] { new { Name = "", CreationTimeUtc = "", LastWriteTimeUtc = "", Length = 0L } } });

            var helper = new FileSystemWatcherHelper()
            {
                NeedRebuild = false,
                _directoryInfo = new DirectoryInfo(data.Directory)
            };

            foreach (var fileInfo in data.FileInfos)
            {
                var fi = new FileInfo(Path.Combine(data.Directory, fileInfo.Name))
                {
                    Length = fileInfo.Length,
                    CreationTimeUtc = DateTime.Parse(fileInfo.CreationTimeUtc).ToUniversalTime(),
                    LastWriteTimeUtc = DateTime.Parse(fileInfo.LastWriteTimeUtc).ToUniversalTime()
                };
                helper._files.Add(fi.FullName, fi);
            }

            helper.CaptureDirectory();
            return helper;
        }
    }
}