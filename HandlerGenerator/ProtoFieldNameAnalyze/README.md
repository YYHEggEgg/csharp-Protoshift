# 分析 Protobuf 编译后字段的名称

众所周知，Protobuf 使用一种类似于驼峰命名法的方法在编译后重命名字段，但它具有很多 corner case。

这里为了替代自行推断字段名可能产生的 bug，使用了另一种方法——让 protoc 来处理。

先来看一组例子：

```proto
syntax = "proto3";
enum StringPool {
    identifier = 0;
    client_config_encrypted = 1;
    server_secret_key = 2;
    client_secret_key = 3;
    region_info = 4;
    Unk3300_HBFVIJDNJ = 5;
}
```

将其编译将会得到以下代码：

```cs
// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: StringPool.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code
...
#region Enums
public enum StringPool {
  [pbr::OriginalName("identifier")] Identifier = 0,
  [pbr::OriginalName("client_config_encrypted")] ClientConfigEncrypted = 1,
  [pbr::OriginalName("server_secret_key")] ServerSecretKey = 2,
  [pbr::OriginalName("client_secret_key")] ClientSecretKey = 3,
  [pbr::OriginalName("region_info")] RegionInfo = 4,
}

#endregion


#endregion Designer generated code
```

可以看到，对于每个 enum 字段，protoc 会在其中标识其原来定义的名字（message 生成的代码则不会有）。  
那么可以想到一种极为方便的方式：收集所有 proto 的字段，将其收集入一个“字符串池”proto，然后通过编译生成的代码来获取字段名。

但是 protoc 对于 enum 仍会进行特殊处理，可能会导致生成的字段名被影响（比如前半段与 enum 名重合而被省略）。如何解决？  
针对这种情况，易知多个 enum 名不可能为同一个字段名的前缀。因此只需要通过不同的 enum 名生成三份代码，取出现过至少两次的名字即可。